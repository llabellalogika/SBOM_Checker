from __future__ import annotations

from typing import Dict, Iterable, List, Optional, Set

from urllib.parse import urlparse

from core.nvd_scanner import get_vulns_nvd
from core.osv_scanner import get_vulns_osv


def _derive_aliases_from_references(references: Optional[Iterable[str]]) -> Set[str]:
    aliases: Set[str] = set()
    for ref in references or []:
        try:
            parsed = urlparse(ref)
        except Exception:
            continue
        if parsed.netloc.lower() == "github.com":
            parts = [p for p in parsed.path.split("/") if p]
            if parts:
                aliases.add(parts[-1])
                if len(parts) >= 2:
                    aliases.add("/".join(parts[:2]))
        elif ref.lower().startswith("cpe:"):
            segments = ref.split(":")
            if len(segments) > 4 and segments[3]:
                aliases.add(segments[3])
    return aliases


def get_known_vulnerabilities(
    name: str,
    version: str,
    *,
    purl: Optional[str] = None,
    references: Optional[Iterable[str]] = None,
    cpe: Optional[str] = None,
    aliases: Optional[Iterable[str]] = None,
) -> List[Dict]:
    """Restituisce le vulnerabilitÃ  note interrogando OSV e, in fallback, NVD."""

    vulns = []

    osv_vulns = get_vulns_osv(name, version, purl=purl, references=references or [])
    for item in osv_vulns:
        entry = {
            "id": item.get("id", "UNKNOWN"),
            "summary": item.get("summary", ""),
            "source": "OSV",
            "references": [ref.get("url") for ref in item.get("references", []) if isinstance(ref, dict) and ref.get("url")],
        }
        vulns.append(entry)

    if vulns:
        return vulns

    alias_set: Set[str] = set(aliases or [])
    alias_set.update(_derive_aliases_from_references(references))
    nvd_vulns = get_vulns_nvd(name, version, cpe=cpe, aliases=sorted(alias_set))
    vulns.extend(nvd_vulns)

    return vulns
